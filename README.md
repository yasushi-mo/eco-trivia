# ディレクトリ構造

```
/eco-trivia
├── packages/
│   ├── frontend/  # Reactアプリケーション（App）
│   ├── backend/   # Expressサーバー（App）
│   └── shared/    # 共通の型定義やユーティリティ（Library/Package）
└── package.json   # ルートのpackage.json
```

※npm workspaces の仕組み上、frontend、backend、shared の全てを workspaces フィールドが認識できる packages ディレクトリ内に配置することが、設定のシンプルさと一貫性を保つ上で最も効果的です。shared は他のパッケージから参照される内部ライブラリとして機能します。

# TSConfig

## ルートとサブパッケージの `tsconfig.json` の役割分担

### 1. ルート `tsconfig.json` の役割：設定の継承と参照（設計図）

ルート (`./tsconfig.json`) は、実際にファイルをコンパイルする役割を持っていません。その役割は、以下の 2 点に特化しています。

- 共通ルールの定義: プロジェクト全体で共通するルール (`"target": "es2023"`, `"strict": true`, `"moduleResolution": "bundler"`) を一度だけ定義し、一貫性を確保します。
- パッケージ参照 (`references`): `packages/shared`, `packages/backend` など、モノレポ内のどのパッケージがビルド可能かをコンパイラに教えます。

ルートの設定に `outDir` や `rootDir` を設定しないのは、ルート自体はコンパイルの起点ではないためです。ルートのファイルにこれらの設定を加えると、全てのソースコードがルートに一元的にビルドされてしまい、モノレポの構造が崩れてしまいます。

### 2. サブパッケージの役割：ビルドの設定（実行部隊）

サブパッケージ (`packages/shared/tsconfig.json` など) は、実際にそのパッケージのコードをコンパイルする「実行部隊」です。

- `"extends": "../tsconfig.json"`: ルートで定義された共通ルール（`strict` や `target` など）をすべて受け取ります。
- `"outDir": "./dist"`: **「このパッケージのビルド結果は、このパッケージのディレクトリ内の `./dist` に出してください」**という指示です。
- `"rootDir": "./src"`: **「このパッケージのソースコードは、このパッケージのディレクトリ内の ./src にあります」**という指示です。

これにより、各パッケージは独立したビルド設定を持ち、ビルド成果物 (`dist`) がそれぞれのパッケージ内に閉じ込められ、モノレポとしてクリーンに保たれます。

## ルート

ルートの `tsconfig.json` に記述されている各項目について、それぞれの役割と目的を解説します。

### `compilerOptions` (コンパイラオプション)

このセクションは、TypeScript コードを JavaScript に変換する際の挙動を細かく定義する、最も重要な部分です。

| 設定項目                               | 値        | 目的と役割                                                                                                                                                                                                                                        |
| :------------------------------------- | :-------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **`target`**                           | `es2023`  | 生成される JavaScript のバージョンを**ECMAScript 2023**に指定します。これにより、コンパイラがモダンな JavaScript の機能（例: `at()` メソッド、正規表現の変更など）をそのまま利用できるため、より効率的でクリーンなコードが出力されます。          |
| **`module`**                           | `esnext`  | どのモジュールシステムを使用するかを指定します。`esnext` は、ES Modules の最新かつ柔軟な形式を指定しており、主に **Vite** や最新の **Node.js** 環境で推奨される設定です。                                                                         |
| **`moduleResolution`**                 | `bundler` | モジュールをどのように解決するか（インポートパスをどう探すか）の戦略を指定します。最新の **Node.js** の動作に合わせたモジュール解決戦略を使用します。                                                                                             |
| **`strict`**                           | `true`    | **TypeScript の厳格な型チェックをすべて有効**にします（`strictNullChecks`, `noImplicitAny` など）。これにより、実行時のエラーを防ぎ、コードの信頼性が大幅に向上します。現代の TypeScript 開発では必須とされる設定です。                           |
| **`esModuleInterop`**                  | `true`    | **CommonJS** モジュール（`require()`）と **ES Modules**（`import`）の互換性を高めます。異なるモジュール形式のライブラリが混在しても、統一された `import` 構文で扱えるようになります。                                                             |
| **`skipLibCheck`**                     | `true`    | `node_modules` 内にある宣言ファイル（`.d.ts`）の型チェックをスキップします。これにより、ライブラリ側の型の不整合によるエラーを無視し、**コンパイル時間を短縮**できます。                                                                          |
| **`forceConsistentCasingInFileNames`** | `true`    | ファイル名の大文字・小文字の区別を厳密に強制します。これにより、Windows や macOS（大文字・小文字を区別しないファイルシステム）で開発しても、Linux（大文字・小文字を区別する）などの環境でデプロイした際に発生する**インポートエラーを防ぎます**。 |
| **`resolveJsonModule`**                | `true`    | `.json` ファイルをモジュールとしてインポートできるようにします。設定ファイルなどを TypeScript コード内から直接読み込む際に便利です。                                                                                                              |
| **`isolatedModules`**                  | `true`    | **Babel** や **Vite** のようなトランスパイラ（単一ファイル変換ツール）と連携する際に推奨される設定です。TypeScript の機能のうち、ファイルを超えた情報が必要な機能（例: `const enum`）の使用を禁止し、ビルドの高速化と安全性を確保します。         |

---

### `references` (参照設定)

このセクションは、このファイルがモノレポ内の他の TypeScript プロジェクトを参照していることを示します。

| 設定項目         | 目的と役割                                                                                                                                                                                                                                                                                                                                                                                         |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **`references`** | モノレポ機能において、このルートの `tsconfig.json` が、配下の **`shared`**, **`backend`**, **`frontend`** の各プロジェクトを参照していることをコンパイラに伝えます。これにより、コンパイラはパッケージ間の依存関係を正確に把握し、`shared` パッケージの変更があった場合、依存する `backend` や `frontend` のみを選択的に再ビルドできるようになります。これは**ビルドの効率化**に不可欠な設定です。 |

この設定は、モダンな TypeScript 開発において、厳格な型チェックと、モノレポでの効率的なビルドを両立させるための**ベストプラクティス**に基づいています。

## サブパッケージ

`tsconfig.json` で `outDir` や `rootDir` をわざわざ明記する理由は、**「責務の分離」**と**「ビルド成果物の自己完結性」**という、モノレポ運用において非常に重要な原則を確立するためです。
これは、共通設定を継承しつつ、個々のパッケージの**独立性**を保証する仕組みです。

### 1. `outDir`: ビルド成果物の自己完結性

`"outDir": "./dist"` を設定する最大の理由は、**そのパッケージのビルド結果を、必ずそのパッケージ自身のディレクトリ内に閉じ込める**ためです。

- **成果物の隔離**: `backend` のビルド結果 (`.js` ファイル) は、`packages/backend/dist` にのみ出力されます。もしこの設定がなければ、コンパイラがルートや別の場所にファイルを散らしてしまう可能性があります。
- **クリーンな構造**: 他のパッケージのビルド成果物と混ざることを防ぎます。これにより、Git の操作（特定のパッケージのみをコミット、またはクリーンアップ）や、Docker を使ったデプロイ（特定の `dist` フォルダだけをコピー）が容易になります。

### 2. `rootDir`: ソースコードの構造維持と明示

`"rootDir": "./src"` を設定する目的は、主に**コンパイルされたファイルの出力構造を制御**し、どこにソースコードがあるかを**明示**することです。

- **構造の維持**: `rootDir` を指定することで、TypeScript コンパイラは、`rootDir` のディレクトリ構造をそのまま `outDir` に再現します。
  - 例: ソースが `packages/shared/src/types/user.ts` の場合、出力は `packages/shared/dist/types/user.js` となります。
- **意図の明示**: `include` オプションだけではコンパイル対象は指定できますが、`rootDir` を指定することで、**「このディレクトリがパッケージのソースコードのルートである」**という開発者とコンパイラへの強いメッセージになります。

### ルートの継承だけでは不十分な理由

サブパッケージがルートの `tsconfig.json` を `extends` しているだけでは、`outDir` や `rootDir` は継承されません。なぜなら、**ルートファイルはビルド場所を指定する必要がない**ため、これらの設定が含まれていないからです。

したがって、各パッケージは「共通ルールはルートから継承するが、**ビルドのインプットとアウトプットの場所**だけは、自分自身のローカルパスで明確に指定する」という責務を負うことになります。
